function [ cells ] = calc_dFF( stackInfo, logfileTimes, timeLastEvent, corrFactor )
% % calc_dFF %
%PURPOSE:   Calculate dF/F from raw fluorescence files (generated by the
%           cellROI program)
%AUTHORS:   AC Kwan 170515
%
%INPUT ARGUMENTS
%   stackInfo:      content of the stackInfo.mat file for this imaging session
%   logfileTimes:   the time in which Presentation sends TTL pulse to ScanImage
%                   to trigger a new .tiff file
%   timeLastEvent:  the time of the last event logged by Presentation
%   corrFactor:     scaling factor, determines how much neuropil
%                   subtraction to apply F(t) = F_soma(t) - (alpha *
%                   F_neuropil(t)); correction factor is alpha. F(t) is the
%                   per-pixel pixel value for the ROI

%OUTPUT ARGUMENTS
%   cells:          a structure containing fields, including dFF

%% CALCULATE dF/F FOR EACH CELL

%if no correction factor specified, assume no neuropil correction
if nargin < 4
    corrFactor = 0;
end

%dF/F = (F(t)-Fo)/Fo
%to estimate Fo (baseline fluorescence), set moving window for smoothing
cells.frameRate = stackInfo.frameRate;
win = 10*60*stackInfo.frameRate;  %window duration = 10 minutes

rois = dir('*cell*.mat');
if numel(rois) > 0  %if there were any cells
    
    disp(['Calculating dF/F (may take several minutes)...']);
    for i = 1:numel(rois)
        celldata = load(rois(i).name);
        
        disp(['Cell ' int2str(i) '/' int2str(numel(rois))]);
        f = celldata.cellf(:);
        
        %neuropil subtraction
        if corrFactor > 0   %if we are correcting for neuropil
            if sum(~isnan(celldata.neuropilf))>0    %if neuropil data was extracted, and not NaN
                neuropilf = celldata.neuropilf(:);
                f = f - corrFactor * neuropilf;
            else
                error('Wanted to correct for neuropil, but the neuropil signal is NaN');
            end
        end
        
        baseline = nan(size(f));
        for j = 1:length(f)
            idx1 = max(1,round(j-win/2));
            idx2 = min(length(f),round(j+win/2));
            %the following step cuts time from 124 sec to 25 sec per cell, for ~60 min resonant imaging data
            idxStep=max([1 round(0.25*stackInfo.frameRate)]); %use frames up to every 1/4 s
            baseline(j) = prctile(f(idx1:idxStep:idx2),10); %10th percentile of F(t)
        end
        cells.cellf{i} = f; %All column vectors
        cells.baseline{i} = baseline;
        cells.dFF{i} = (f-baseline)./(baseline);
        
        cells.bw{i} = celldata.bw;
        cells.isRedCell{i} = celldata.isRedCell;
    end
    
    %% CREATE TIME VECTOR FOR ALIGNMENT WITH BEHAVIORAL/PHYSIOLOGICAL DATA
    
    %Start of an .tiff file is the behavioral trial start time adjusted by
    %trigDelay (Presentation sends trigger to ScanImage to request start of a
    %new file, slight delay until current frame is completed to start the new
    %file)
    
    %ScanImage 5 does not store 'trigDelay' explicitly
    %However, the frameTime stored by ScanImage and the event times stored by
    %Presentation are different by ~0.1 s after 60 min of imaging
    %So it is much better to re-align the imaging/behavior timing at every image
    %acquisition trigger
    if ~isfield(stackInfo,'trigDelay')  %If ScanImage5, we will reproduce the trigDelay variable
        t=stackInfo.frameTime-stackInfo.frameTime(1);
        
        trigDelay=0;
        for n=1:numel(stackInfo.num_frames)-1
            trigDelay=[trigDelay t(sum(stackInfo.num_frames(1:n))+1)-stackInfo.fileNextTime(n+1)];
        end
        stackInfo.trigDelay = trigDelay;
        clear trigDelay;
    end
    
    %For alignment, we find out when logfile recorded sending a TTL pulse, and
    %use those time stamps to set the time of the first image frame of each
    %.tiff file.
    %For ScanImage version 5.x, time of each frame is logged into
    %stackinfo.mat. This is more accurate than estimating using the average
    %frame rate
    stackFrameTimes = [];
    nFrames = stackInfo.num_frames;  %number of frames in each tiff file
    dt = 1/stackInfo.frameRate;             %the frame rate
    if isfield(stackInfo,'scim_ver')
        if (stackInfo.scim_ver == 5)
            %time of individual frames in a .tiff, relative to the first frame
            stackFrameTimes{1} = stackInfo.frameTime(1:nFrames(1)) - stackInfo.frameTime(1);
            for i = 2:numel(stackInfo.num_frames)
                idx = sum(stackInfo.num_frames(1:i-1));
                stackFrameTimes{i} = stackInfo.frameTime(idx+(1:nFrames(i))) - stackInfo.frameTime(idx+1);
            end
        end
    end
    %For ScanImage version 3.x, for the image frames in .tiff after the
    %first image frame, we estimate its time based on the frame rate.
    %(often stackInfo does not have the field 'scim_ver')
    if isempty(stackFrameTimes)
        %time of individual frames in a .tiff, relative to the first frame
        for i = 1:numel(stackInfo.num_frames)   %for each .tiff
            stackFrameTimes{i} = [0:dt:dt*(nFrames(i)-1)];
        end
    end
    
    %% Different processing depending on the number of imaging files and number of behavioral log files
    if numel(logfileTimes) == numel(stackInfo.trigDelay)
        %same number of imaging files as number of trials, as it should be
        stackTimes = logfileTimes' - stackInfo.trigDelay;
        
        for i = 1:numel(stackTimes)
            frameTimes{i} = stackTimes(i)+stackFrameTimes{i};
        end
        cells.t = [frameTimes{:}]'; %Column vector
        
    elseif numel(logfileTimes) < numel(stackInfo.trigDelay)
        %behavior aborted before imaging finishes;
        %could happen if Presentation program was stopped before stopping
        %imaging at ScanImage
        disp(['CAUTION: Behavioral start times (' int2str(numel(logfileTimes)) ') < imaging triggers (' int2str(numel(stackInfo.trigDelay)) '); inconsistent number of trials/files. CHECK!']);
        
        %Solution -- crop the fluorescence data
        stackTimes = logfileTimes' - stackInfo.trigDelay(1:numel(logfileTimes));
        cropIdx=sum(stackInfo.num_frames(1:numel(logfileTimes))); %save only frames up to end of last behavioral trial
        for i=1:numel(rois)
            cells.cellf{i} = cells.cellf{i}(1:cropIdx);
            cells.baseline{i} = cells.baseline{i}(1:cropIdx);
            cells.dFF{i} = cells.dFF{i}(1:cropIdx);
        end
        
        for i = 1:numel(stackTimes)
            frameTimes{i} = stackTimes(i)+stackFrameTimes{i};
        end
        cells.t = [frameTimes{:}]'; %Column vector
        
    else
        %imaging aborted before behavior finishes
        %could happen if imaging set at a certain duration (1 hr), but
        %Presentation keeps going, for example if experimenter starts
        %session but needs to go somewhere and cannot attend microscope
        disp(['CAUTION: Behavioral start times (' int2str(numel(logfileTimes)) ') > imaging triggers (' int2str(numel(stackInfo.trigDelay)) '); inconsistent number of trials/files. CHECK!']);
        
        %Solution -- create fluorescence data so imaging length matches the behavior length
        %these additional fluorescence data will be filled entirely with NaN's
        stackTimes = logfileTimes(1:numel(stackInfo.trigDelay))' - stackInfo.trigDelay;
        
        for i = 1:numel(stackTimes)
            frameTimes{i} = stackTimes(i)+stackFrameTimes{i};
        end
        cells.t = [frameTimes{:}]'; %Column vector
        
        % extend imaging time/data to the last known event logged by Presentation
        cells.t = [cells.t; (cells.t(end)+dt:dt:timeLastEvent)'];
        for i=1:numel(rois)
            cells.dFF{i} = [cells.dFF{i}; nan(numel(cells.t) - numel(cells.dFF{i}),1)];
        end
    end
    
    %% if there is more imaging frames logged in stackInfo.mat than actual imaging data
    % could happen if imaging data were cropped, e.g. due to motion artifact or
    % significant drift that appears late in the imaging session
    
    if sum(stackInfo.num_frames) > numel(cells.dFF{1})
        disp(['CAUTION: Supposedly has more frames (' int2str(sum(stackInfo.num_frames)) ') than extracted imaging data (' int2str(numel(cells.dFF{1})) '); imaging data cropped? CHECK!']);
        
        cells.t = cells.t(1:numel(cells.dFF{1}));
    end
    
    % there is one more frame of extracted .tiff than specified in the
    % stackInfo meta information. Current guess is this represents the last
    % incomplete frame? (e.g. this happened for 778/5 Social defeat/, after
    % aligning to behavioral triggers, frame timing is fairly consistent
    % and there is no obvious place for one dropped frame)
    if sum(stackInfo.num_frames) == numel(cells.dFF{1}) - 1
        disp(['CAUTION: One less frames (' int2str(sum(stackInfo.num_frames)) ') than extracted imaging data (' int2str(numel(cells.dFF{1})) '); CHECK!']);
        
        for j = 1:numel(cells.dFF)
            cells.cellf{j} = cells.cellf{j}(1:numel(cells.t));
            cells.baseline{j} = cells.baseline{j}(1:numel(cells.t));
            cells.dFF{j} = cells.dFF{j}(1:numel(cells.t));
        end
    end
    
    
end

end